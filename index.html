<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Energy Canvas</title>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        :root {
            --gold-color: #ffc300;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }
        canvas { 
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }

        /* --- Modal --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.4s ease, visibility 0.4s ease; backdrop-filter: blur(5px);
        }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content {
            background: #0a0a0a;
            border: 2px solid var(--gold-color);
            width: 450px;
            height: 450px;
            max-width: 90vw;
            max-height: 90vw;
            border-radius: 50%;
            padding: 40px;
            box-sizing: border-box;
            color: #eee;
            box-shadow: 0 0 40px var(--gold-color), inset 0 0 15px rgba(255, 195, 0, 0.3);
            position: relative;
            transform: scale(0.8) rotate(-10deg);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .modal.active .modal-content { transform: scale(1) rotate(0deg); }
        .modal-content h2 { 
            margin-top: 0; 
            margin-bottom: 20px;
            font-size: 2.5rem;
            color: var(--gold-color); 
            transition: color 0.3s ease; 
        }
        .modal-content p {
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
        }
        .modal-close {
            position: absolute;
            top: 22%;
            right: 22%;
            transform: translate(50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff; cursor: pointer; transition: color 0.2s, transform 0.2s;
        }
        .modal-close:hover { color: #ffc300; transform: translate(50%, -50%) scale(1.2); }
        
    </style>
</head>
<body>
    <canvas id="cosmicCanvas"></canvas>

    <div class="modal" id="serviceModal">
        <div class="modal-content">
            <span class="modal-close" id="modalClose">&times;</span>
            <h2 id="modalTitle"></h2>
            <p id="modalDescription"></p>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('cosmicCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centralFigureImage = new Image();
        let imageFailedToLoad = false;
        centralFigureImage.crossOrigin = "Anonymous"; 
        centralFigureImage.onload = () => { run(); };
        centralFigureImage.onerror = () => { imageFailedToLoad = true; run(); };
        centralFigureImage.src = 'https://i.imgur.com/Zclc7ji.png';

        let stars = [], renderables = [], particles = [], dust = [], shootingStars = [];
        let nebulaCanvas;
        const STAR_COUNT = 500; 
        const DUST_COUNT = 100;
        const BRANCH_COUNT = 30;
        const GOLD_COLOR = '#ffc300';
        const DARK_GOLD_COLOR = '#ff9400';
        let globalScale = 1.0;
        let isDragging = false;
        let hasDragged = false;
        let lastMouseX = 0, lastMouseY = 0;
        let rotationX = 0, rotationY = 0;
        let tugOffsetX = 0, tugOffsetY = 0;
        let targetTugOffsetX = 0, targetTugOffsetY = 0;
        let isIntroAnimationDone = false;
        const introDuration = 2500; 
        let introStartTime = null;
        let beamStartTime = null;
        const beamDuration = 600;
        let isHoveringFigure = false;
        let targetFigureScale = 1.0;
        let currentFigureExtraScale = 1.0;
        let isSubMenuOpen = false;

        const serviceData = {
            music: { title: "Music", full: "My musical services are designed to give your project a polished, studio-quality sound. I offer custom theme song creation, a bespoke service for brands and individuals seeking a unique sonic signature. I also provide professionally engineered vocal presets for Bandlab, helping artists achieve a professional sound with ease." },
            ai: { title: "AI", full: "Harness the power of artificial intelligence. I specialize in building and configuring custom GPTs trained on your specific data and needs. From automating repetitive tasks to creating powerful new creative tools, I design AI solutions that harmonize technology and humanity." },
            design: { title: "Art/Digital Media", full: "Storytelling through image, motion, and experience. I offer creative services for artists and businesses, including the creation of compelling AI-powered video ads and mesmerizing music visualizers for your tracks. Let's bring your vision to life." },
            engineering: { title: "Engineering/Startups", full: "Building tools, systems, and futures. My engineering services cover web development on modern platforms and custom frontend work, as well as smart automation and creative problem-solving. I focus on building with intention to create beautiful and performant digital products." }
        };
        
         const serviceConfig = {
            // --- CHANGE: Repositioned nodes for a symmetrical, meaningful layout
            'ai':          { theta: Math.PI * 1.5,  phi: Math.PI * 0.5, colors: ['#8A2BE2', '#00BFFF'], icon: '\uf544' }, // Top (Head)
            'design':      { theta: Math.PI * 1.8,  phi: Math.PI * 0.5, colors: ['#FF4500', '#FF0000'], icon: '\uf1fc' }, // Upper Right (Right Arm)
            'engineering': { theta: Math.PI * 1.2,  phi: Math.PI * 0.5, colors: ['#0000FF', '#FFFF00'], icon: '\uf085' }, // Upper Left (Left Arm)
            'music':       { theta: Math.PI * 0.5,  phi: Math.PI * 0.5, colors: ['#39ff14', '#ff00ff'], icon: '\uf001' }  // Bottom (Feet)
        };

        function createNebula() {
            const size = 1024;
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = size; offscreenCanvas.height = size;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            const colors = ['#4a1c54', '#1f195e', '#133b6d'];
            offscreenCtx.fillStyle = '#000';
            offscreenCtx.fillRect(0, 0, size, size);
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * size, y = Math.random() * size;
                const radius = Math.random() * size / 3 + size / 5;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const grad = offscreenCtx.createRadialGradient(x, y, 0, x, y, radius);
                grad.addColorStop(0, color + '40');
                grad.addColorStop(1, color + '00');
                offscreenCtx.fillStyle = grad;
                offscreenCtx.fillRect(0, 0, size, size);
            }
            return offscreenCanvas;
        }

        // --- NEW: Class for shooting stars
        class ShootingStar {
            constructor() {
                const isVertical = Math.random() > 0.5;
                if (isVertical) {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() > 0.5 ? -50 : canvas.height + 50;
                } else {
                    this.x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                }
                
                const angleToCenter = Math.atan2(canvas.height / 2 - this.y, canvas.width / 2 - this.x);
                const spread = Math.PI / 4;
                this.angle = angleToCenter + (Math.random() - 0.5) * spread;

                this.speed = Math.random() * 8 + 5;
                this.velX = Math.cos(this.angle) * this.speed;
                this.velY = Math.sin(this.angle) * this.speed;
                this.size = Math.random() * 1.5 + 0.5;
                this.life = 1; // opacity
                this.alive = true;
            }

            update() {
                this.x += this.velX;
                this.y += this.velY;
                this.life -= 0.01;
                if (this.life <= 0) {
                    this.alive = false;
                }
            }

            draw(ctx) {
                const tailLength = 15;
                const tailX = this.x - this.velX * tailLength;
                const tailY = this.y - this.velY * tailLength;
                const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.life})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(this.x, this.y);
                ctx.lineWidth = this.size;
                ctx.strokeStyle = gradient;
                ctx.stroke();
            }
        }


        class Star {
            constructor() {
                this.radius3d = Math.random() * (canvas.width * 1.2) + (canvas.width * 0.3);
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                this.x3d = this.radius3d * Math.sin(phi) * Math.cos(theta);
                this.y3d = this.radius3d * Math.sin(phi) * Math.sin(theta);
                this.z3d = this.radius3d * Math.cos(phi);
                this.originalRadius = Math.random() * 1.5 + 0.5;
            }
            project(rotX, rotY) {
                const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                const tempX1 = this.x3d * cosY - this.z3d * sinY;
                const tempZ1 = this.x3d * sinY + this.z3d * cosY;
                this.rotatedX = tempX1;
                this.rotatedY = this.y3d * cosX - tempZ1 * sinX;
                this.rotatedZ = this.y3d * sinX + tempZ1 * cosX;
                const perspective = canvas.width * 0.8;
                const scale = perspective / (perspective + this.rotatedZ);
                this.screenX = canvas.width / 2 + this.rotatedX * scale;
                this.screenY = canvas.height / 2 + this.rotatedY * scale;
                this.screenRadius = this.originalRadius * scale;
                this.alpha = (this.rotatedZ + this.radius3d) / (this.radius3d * 2);
            }
            draw() {
                if (this.screenRadius < 0) return;
                ctx.beginPath();
                ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.fill();
            }
        }

        class CosmicDust extends Star {
            constructor() {
                super();
                this.radius3d = Math.random() * (canvas.width * 0.5) + (canvas.width * 0.1);
                this.originalRadius = Math.random() * 0.8 + 0.2;
                this.color = `hsl(${Math.random() * 60 + 200}, 100%, 80%)`;
            }
            draw() {
                if (this.screenRadius < 0) return;
                ctx.beginPath();
                ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha * 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        class Node extends Star {
            constructor(serviceKey, config) {
                super();
                // --- CHANGE: Brought nodes closer to the center
                this.baseRadius3d = canvas.width * 0.25;
                this.theta = config.theta; this.phi = config.phi;
                this.originalRadius = 35;
                this.serviceKey = serviceKey;
                this.colors = config.colors; this.icon = config.icon;
                this.isActivated = false; this.isHovered = false; this.activationProgress = 0;
            }
            project(rotX, rotY, zoomScale) {
                this.radius3d = this.baseRadius3d; // Fixed distance from center
                this.x3d = this.radius3d * Math.sin(this.phi) * Math.cos(this.theta);
                this.y3d = this.radius3d * Math.sin(this.phi) * Math.sin(this.theta);
                this.z3d = this.radius3d * Math.cos(this.phi);
                super.project(rotX, rotY);
                this.screenRadius *= zoomScale;
            }
            draw(timestamp) {
                if (this.activationProgress < 1 && this.isActivated) this.activationProgress += 0.05;
                const currentScale = easeInOutCubic(this.activationProgress);
                if (!this.isActivated || this.screenRadius < 0) return;
                const pulse = this.isHovered ? 1.1 : 1 + Math.sin(timestamp / 500) * 0.05;
                const finalRadius = this.screenRadius * currentScale * pulse;

                // --- CHANGE: Reduced glow strength and radius
                const glowGradient = ctx.createRadialGradient(this.screenX, this.screenY, finalRadius * 0.8, this.screenX, this.screenY, finalRadius * 1.4);
                glowGradient.addColorStop(0, this.colors[0] + '40'); 
                glowGradient.addColorStop(1, this.colors[1] + '00');
                ctx.fillStyle = glowGradient; ctx.beginPath(); ctx.arc(this.screenX, this.screenY, finalRadius * 1.4, 0, Math.PI * 2); ctx.fill();

                const bodyGradient = ctx.createRadialGradient(this.screenX - finalRadius * 0.2, this.screenY - finalRadius * 0.2, finalRadius * 0.1, this.screenX, this.screenY, finalRadius);
                bodyGradient.addColorStop(0, this.colors[0]); bodyGradient.addColorStop(1, this.colors[1]);
                ctx.fillStyle = bodyGradient; ctx.beginPath(); ctx.arc(this.screenX, this.screenY, finalRadius, 0, Math.PI * 2); ctx.fill();
                
                const highlightGradient = ctx.createRadialGradient(this.screenX - finalRadius * 0.4, this.screenY - finalRadius * 0.4, 0, this.screenX, this.screenY, finalRadius);
                highlightGradient.addColorStop(0, 'rgba(255,255,255,0.4)'); highlightGradient.addColorStop(0.5, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlightGradient; ctx.fill();
                
                ctx.font = `900 ${finalRadius * 0.8}px "Font Awesome 5 Free"`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.icon, this.screenX, this.screenY);

                if (this.isHovered) {
                    ctx.font = `bold ${finalRadius * 0.5}px Segoe UI`;
                    ctx.fillStyle = '#ffffff'; ctx.shadowColor = this.colors[0]; ctx.shadowBlur = 10;
                    ctx.fillText(serviceData[this.serviceKey].title, this.screenX, this.screenY + finalRadius * 1.5);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        class Figure {
             constructor() { this.rotatedZ = 0; }
             project() { this.rotatedZ = 0; }
             draw(timestamp, dynamicOriginX, dynamicOriginY, currentFigureScale, introProgress, zoomScale) {
                if (imageFailedToLoad || !centralFigureImage.complete) return;
                const finalScale = currentFigureScale * currentFigureExtraScale * zoomScale;
                const figHeight = canvas.height * finalScale;
                const figWidth = centralFigureImage.naturalWidth * (figHeight / centralFigureImage.naturalHeight);
                let glowStrength1, glowStrength2;
                if(isIntroAnimationDone) {
                    const pulse = (Math.sin(timestamp / 800) + 1) / 2; 
                    glowStrength1 = 10 + pulse * 15;
                    glowStrength2 = 25 + pulse * 30;
                    if(isHoveringFigure) { glowStrength1 = 30; glowStrength2 = 70; }
                } else {
                    glowStrength1 = 15 * introProgress;
                    glowStrength2 = 35 * introProgress;
                }
                ctx.save();
                ctx.filter = `drop-shadow(0 0 ${glowStrength1}px ${GOLD_COLOR}) drop-shadow(0 0 ${glowStrength2}px ${DARK_GOLD_COLOR})`;
                ctx.drawImage(centralFigureImage, dynamicOriginX - figWidth / 2, dynamicOriginY - figHeight / 2, figWidth, figHeight);
                ctx.restore();
            }
        }

        class Branch {
            constructor(staticX, staticY, angle, depth) {
                this.staticX = staticX; this.staticY = staticY;
                this.originX = staticX; this.originY = staticY;
                this.angle = angle; this.depth = depth;
                this.maxLength = Math.random() * 200 + 100 + (5 - depth) * 50;
                this.currentLength = 0;
                this.speed = (Math.random() * 1 + 0.5) * 1.5;
                this.lineWidth = Math.random() * 0.5 + (4 - depth) * 0.3;
                this.children = [];
                this.isGrown = false;
                this.oscillationRadius = Math.random() * 15 + 5;
                this.oscillationSpeed = (Math.random() * 0.5 + 0.5) * 0.001;
                this.oscillationOffset = Math.random() * Math.PI * 2;
            }
            update(timestamp) {
                if (this.depth === 2) { 
                    const angle = timestamp * this.oscillationSpeed + this.oscillationOffset;
                    this.originX = this.staticX + Math.cos(angle) * this.oscillationRadius;
                    this.originY = this.staticY + Math.sin(angle) * this.oscillationRadius;
                }
                this.children.forEach(child => child.update(timestamp));
            }
            grow() {
                if (this.currentLength < this.maxLength) {
                    this.currentLength += this.speed;
                } else if (!this.isGrown) {
                    this.isGrown = true;
                    if (this.depth > 0) {
                        const endX = this.staticX + this.maxLength * Math.cos(this.angle);
                        const endY = this.staticY + this.maxLength * Math.sin(this.angle);
                        const angleOffset = Math.PI / (Math.random() * 4 + 4);
                        this.children.push(new Branch(endX, endY, this.angle - angleOffset, this.depth - 1));
                        this.children.push(new Branch(endX, endY, this.angle + angleOffset, this.depth - 1));
                    }
                }
                this.children.forEach(child => child.grow());
            }
            draw(startX, startY, zoomScale) {
                const endX = startX + this.currentLength * Math.cos(this.angle);
                const endY = startY + this.currentLength * Math.sin(this.angle);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = GOLD_COLOR;
                ctx.stroke();
                this.children.forEach(child => child.draw(endX, endY, zoomScale));
            }
        }

        class EnergyWeb {
            constructor() { this.rotatedZ = 1000; this.branches = []; } // Moved to the back
            project() { this.rotatedZ = 1000; }
            startGrowth() {
                const centerX = canvas.width / 2, centerY = canvas.height / 2;
                this.branches = [];
                for (let i = 0; i < BRANCH_COUNT; i++) {
                    const angle = (Math.PI * 2 / BRANCH_COUNT) * i + (Math.random() - 0.5) * 0.1;
                    const originRadius = (Math.random() * 50 + 80);
                    const branchOriginX = centerX + originRadius * Math.cos(angle);
                    const branchOriginY = centerY + originRadius * Math.sin(angle);
                    this.branches.push(new Branch(branchOriginX, branchOriginY, angle, 2));
                }
            }
            draw(timestamp, dynamicOriginX, dynamicOriginY, zoomScale) {
                ctx.save();
                ctx.translate(dynamicOriginX, dynamicOriginY);
                ctx.scale(zoomScale, zoomScale);
                ctx.translate(-dynamicOriginX, -dynamicOriginY);

                ctx.shadowColor = GOLD_COLOR;
                ctx.shadowBlur = 10;
                this.branches.forEach(branch => { 
                    branch.update(timestamp);
                    branch.grow();
                    ctx.beginPath();
                    ctx.moveTo(dynamicOriginX, dynamicOriginY);
                    ctx.lineTo(branch.originX, branch.originY);
                    ctx.lineWidth = branch.lineWidth;
                    ctx.strokeStyle = GOLD_COLOR;
                    ctx.stroke();
                    branch.draw(branch.originX, branch.originY, zoomScale); 
                });
                ctx.restore();
            }
        }

        class SubMenuItem {
            constructor(text, color, angle, action) {
                this.text = text;
                this.color = color;
                this.angle = angle;
                this.action = action;
                // --- CHANGE: Moved sub-menu behind the central figure
                this.rotatedZ = 1; 
                this.currentLength = 0;
                this.maxLength = 140;
                this.speed = 8;
                this.screenX = 0;
                this.screenY = 0;
                this.isHovered = false;
            }
            project() { this.rotatedZ = 1; }
            isMouseOver(mouseX, mouseY) {
                if (this.currentLength < this.maxLength) return false;
                const textWidth = ctx.measureText(this.text).width;
                const textHeight = 20; // estimate
                return mouseX > this.screenX - textWidth / 2 && mouseX < this.screenX + textWidth / 2 &&
                       mouseY > this.screenY - textHeight / 2 && mouseY < this.screenY + textHeight / 2;
            }
            draw(timestamp, originX, originY, isOpen, zoomScale) {
                if (isOpen && this.currentLength < this.maxLength) this.currentLength += this.speed;
                else if (!isOpen && this.currentLength > 0) this.currentLength -= this.speed * 1.5;
                this.currentLength = Math.max(0, this.currentLength);
                const opacity = easeInOutCubic(this.currentLength / this.maxLength);

                if (opacity > 0) {
                    const effectiveLength = this.currentLength * zoomScale;
                    this.screenX = originX + effectiveLength * Math.cos(this.angle);
                    this.screenY = originY + effectiveLength * Math.sin(this.angle);
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    
                    // Draw line
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    ctx.lineTo(this.screenX, this.screenY);
                    ctx.lineWidth = 2 * zoomScale;
                    ctx.strokeStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.stroke();

                    // Draw text
                    const fontSize = 18 * zoomScale;
                    ctx.font = `bold ${fontSize}px Segoe UI`;
                    ctx.fillStyle = this.isHovered ? '#ffffff' : this.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, this.screenX, this.screenY);
                    ctx.restore();
                }
            }
        }

        class Particle {
            constructor(x, y, targetBranch) {
                this.x = x; this.y = y; this.targetBranch = targetBranch;
                this.progress = 0; 
                this.speed = (Math.random() * 0.3 + 0.2) * 0.01;
                this.lifespan = 1; this.radius = Math.random() * 1.2;
            }
            update() {
                this.progress += this.speed; this.lifespan -= 0.005;
                const targetX = this.targetBranch.originX;
                const targetY = this.targetBranch.originY;
                const startX = canvas.width / 2 + tugOffsetX;
                const startY = canvas.height / 2 + tugOffsetY;
                this.x = startX + (targetX - startX) * this.progress;
                this.y = startY + (targetY - startY) * this.progress;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 220, 150, ${this.lifespan})`;
                ctx.fill();
            }
        }

        function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

        function checkNodeActivations(hoverOffset = 0) {
            const originX = canvas.width / 2 + tugOffsetX;
            const originY = canvas.height / 2 + hoverOffset + tugOffsetY;
            const energyWeb = renderables.find(r => r instanceof EnergyWeb);
            if (!energyWeb) return;

            renderables.forEach(r => {
                if (r instanceof Node && !r.isActivated) {
                    const nodeDist3D = Math.sqrt(r.x3d**2 + r.y3d**2 + r.z3d**2);
                    const checkBranches = (branchList) => {
                        for (const branch of branchList) {
                            const branchDistFromOrigin = Math.sqrt(Math.pow(branch.originX-originX,2) + Math.pow(branch.originY-originY,2));
                            if (branch.currentLength + branchDistFromOrigin >= nodeDist3D) {
                                r.isActivated = true;
                                return;
                            }
                            if (branch.children.length > 0) { checkBranches(branch.children); }
                        }
                    };
                    checkBranches(energyWeb.branches);
                }
            });
        }
        
        function init() {
            stars = []; renderables = []; particles = []; dust = []; shootingStars = [];
            isIntroAnimationDone = false;
            introStartTime = null; beamStartTime = null;
            nebulaCanvas = createNebula();
            for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            for (let i = 0; i < DUST_COUNT; i++) { dust.push(new CosmicDust()); }

            const nodes = Object.keys(serviceConfig).map(key => new Node(key, serviceConfig[key]));
            const figure = new Figure();
            const energyWeb = new EnergyWeb();

            const subMenuItems = [
                new SubMenuItem('Creations', '#00ffff', -Math.PI / 2, 'creations'), // Cyan
                new SubMenuItem('Offerings', '#ff00ff', Math.PI * 1/6, 'offerings'), // Magenta
                new SubMenuItem('Commune', '#39ff14', Math.PI * 5/6, 'commune')   // Neon Green
            ];

            renderables = [...nodes, figure, energyWeb, ...subMenuItems];
        }

        function animate(timestamp) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!isDragging) rotationY += 0.0006;
            
            ctx.save();
            ctx.globalAlpha = 0.5;
            const nebulaRotation = timestamp * 0.00002;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rotationY / 5 + nebulaRotation);
            ctx.drawImage(nebulaCanvas, -nebulaCanvas.width, -nebulaCanvas.height, nebulaCanvas.width * 2, nebulaCanvas.height * 2);
            ctx.restore();

            // --- NEW: Spawn, update, and draw shooting stars
            if (Math.random() > 0.992 && shootingStars.length < 3) {
                shootingStars.push(new ShootingStar());
            }
            shootingStars.forEach(s => s.update());
            shootingStars = shootingStars.filter(s => s.alive);
            shootingStars.forEach(s => s.draw(ctx));


            stars.forEach(star => { star.project(rotationX, rotationY); star.draw(); });
            dust.forEach(d => { d.project(rotationX * 0.5, rotationY * 0.5); d.draw(); });
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const easeFactor = 0.05;
            tugOffsetX += (targetTugOffsetX - tugOffsetX) * easeFactor;
            tugOffsetY += (targetTugOffsetY - tugOffsetY) * easeFactor;
            currentFigureExtraScale += (targetFigureScale - currentFigureExtraScale) * easeFactor;
            
            const hoverOffset = isIntroAnimationDone ? Math.sin(timestamp / 1500) * 10 : 0;
            const dynamicOriginX = centerX + tugOffsetX;
            const dynamicOriginY = centerY + hoverOffset + tugOffsetY;

            let currentFigureY = centerY;
            let currentFigureScale = 0.4;
            let easedProgress = 0;
            const energyWeb = renderables.find(r => r instanceof EnergyWeb);

            if (!isIntroAnimationDone) {
                if (introStartTime === null) introStartTime = timestamp;
                const elapsed = timestamp - introStartTime;
                const progress = Math.min(elapsed / introDuration, 1);
                easedProgress = easeInOutCubic(progress);
                currentFigureY = centerY - (centerY - (canvas.height + 150)) * (1-easedProgress);
                currentFigureScale = 0.05 + (0.4 - 0.05) * easedProgress;
                if (progress === 1) {
                    isIntroAnimationDone = true;
                    beamStartTime = timestamp;
                    energyWeb.startGrowth();
                }
            }
            
            renderables.forEach(r => { if(r.project) r.project(rotationX, rotationY, globalScale); });
            
            renderables.sort((a,b) => b.rotatedZ - a.rotatedZ);
            
            if (isIntroAnimationDone) {
                if (beamStartTime !== null) {
                    const beamElapsed = timestamp - beamStartTime;
                    const beamProgress = Math.min(beamElapsed / beamDuration, 1);
                    const currentBeamHeight = canvas.height * beamProgress;
                    const currentBeamWidth = canvas.width * beamProgress;
                    const vertGradient = ctx.createLinearGradient(centerX, 0, centerX, canvas.height);
                    vertGradient.addColorStop(0, 'rgba(255, 195, 0, 0)'); vertGradient.addColorStop(0.48, DARK_GOLD_COLOR); vertGradient.addColorStop(0.52, DARK_GOLD_COLOR); vertGradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
                    const horizGradient = ctx.createLinearGradient(0, centerY, canvas.width, centerY);
                    horizGradient.addColorStop(0, 'rgba(255, 195, 0, 0)'); horizGradient.addColorStop(0.48, DARK_GOLD_COLOR); horizGradient.addColorStop(0.52, DARK_GOLD_COLOR); horizGradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
                    ctx.save();
                    ctx.fillStyle = vertGradient; ctx.shadowColor = GOLD_COLOR; ctx.shadowBlur = 30;
                    ctx.fillRect(dynamicOriginX - 3, centerY - currentBeamHeight / 2, 6, currentBeamHeight);
                    ctx.fillStyle = horizGradient;
                    ctx.fillRect(centerX - currentBeamWidth / 2, dynamicOriginY - 3, currentBeamWidth, 6);
                    ctx.restore();
                }
                
                if (energyWeb.branches.length > 0 && Math.random() > 0.9) {
                    const targetBranch = energyWeb.branches[Math.floor(Math.random() * energyWeb.branches.length)];
                    particles.push(new Particle(dynamicOriginX, dynamicOriginY, targetBranch));
                }
                checkNodeActivations(hoverOffset);
            }
            
            // Unified Render Loop
            renderables.forEach(r => {
                if (r instanceof EnergyWeb && isIntroAnimationDone) {
                    r.draw(timestamp, dynamicOriginX, dynamicOriginY, globalScale);
                } else if (r instanceof Figure) {
                   r.draw(timestamp, dynamicOriginX, isIntroAnimationDone ? dynamicOriginY : currentFigureY, currentFigureScale, easedProgress, globalScale);
                } else if (r instanceof Node) {
                    r.draw(timestamp);
                } else if (r instanceof SubMenuItem) { 
                    r.draw(timestamp, dynamicOriginX, dynamicOriginY, isSubMenuOpen, globalScale);
                }
            });

            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if(p.lifespan <= 0) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        function run() {
            init();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const zoomAmount = e.deltaY * -zoomSpeed;
            const minScale = 0.5;
            const maxScale = 2.0;
            globalScale = Math.max(minScale, Math.min(maxScale, globalScale + zoomAmount));
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            hasDragged = false;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                  hasDragged = true;
                }

                const rotationSpeed = 0.002;
                rotationY += deltaX * rotationSpeed;
                rotationX += deltaY * rotationSpeed;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                const pullX = e.clientX - canvas.width / 2;
                const pullY = e.clientY - canvas.height / 2;
                const pullStrength = 0.15;
                targetTugOffsetX = pullX * pullStrength;
                targetTugOffsetY = pullY * pullStrength;
            }

            let handledByNode = false;
            renderables.forEach(r => {
                if (r instanceof Node) {
                    const dist = Math.sqrt((e.clientX - r.screenX)**2 + (e.clientY - r.screenY)**2);
                    if (r.isActivated && dist < r.screenRadius * 1.2) {
                        r.isHovered = true;
                        handledByNode = true;
                    } else {
                        r.isHovered = false;
                    }
                }
            });

            let handledBySubMenu = false;
            renderables.forEach(r => {
                if (r instanceof SubMenuItem) {
                    if (r.isMouseOver(e.clientX, e.clientY)) {
                        r.isHovered = true;
                        handledBySubMenu = true;
                    } else {
                        r.isHovered = false;
                    }
                }
            });
            
            const scaledFigHeight = canvas.height * 0.4 * currentFigureExtraScale * globalScale;
            const scaledFigWidth = centralFigureImage.naturalWidth * (scaledFigHeight / centralFigureImage.naturalHeight);
            const figRect = {
                x: (canvas.width / 2 + tugOffsetX) - scaledFigWidth/2,
                y: (canvas.height / 2 + (isIntroAnimationDone ? Math.sin(Date.now() / 1500) * 10 : 0) + tugOffsetY) - scaledFigHeight/2,
                width: scaledFigWidth,
                height: scaledFigHeight
            };
            
            if (!handledByNode && isIntroAnimationDone && e.clientX > figRect.x && e.clientX < figRect.x + figRect.width &&
                e.clientY > figRect.y && e.clientY < figRect.y + figRect.height) {
                isHoveringFigure = true;
                targetFigureScale = 1.05;
            } else {
                isHoveringFigure = false;
                targetFigureScale = 1.0;
            }
            canvas.style.cursor = isHoveringFigure || handledByNode || handledBySubMenu ? 'pointer' : (isDragging ? 'grabbing' : 'grab');
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            targetTugOffsetX = 0;
            targetTugOffsetY = 0;
        });
        
        canvas.addEventListener('click', (e) => {
             if (hasDragged) return;

            if(isHoveringFigure) {
                isSubMenuOpen = !isSubMenuOpen;
            }

            let subMenuItemClicked = false;
            renderables.forEach(r => {
                if (r instanceof SubMenuItem && r.isHovered) {
                    console.log(`Submenu item clicked: ${r.action}`);
                    isSubMenuOpen = false; 
                    subMenuItemClicked = true;
                }
            });

            if (subMenuItemClicked) return;

            renderables.forEach(r => {
                if (r instanceof Node && r.isHovered) {
                    const modal = document.getElementById('serviceModal');
                    const modalContent = modal.querySelector('.modal-content');
                    const modalTitle = document.getElementById('modalTitle');
                    const modalDescription = document.getElementById('modalDescription');
                    
                    modalTitle.textContent = serviceData[r.serviceKey].title;
                    modalDescription.textContent = serviceData[r.serviceKey].full;

                    const gradient = `linear-gradient(45deg, ${r.colors[0]}, ${r.colors[1]})`;
                    modalContent.style.borderColor = r.colors[0];
                    modalContent.style.boxShadow = `0 0 40px ${r.colors[0]}, inset 0 0 15px ${r.colors[1]}a0`;

                    modalTitle.style.background = gradient;
                    modalTitle.style.webkitBackgroundClip = 'text';
                    modalTitle.style.webkitTextFillColor = 'transparent';
                    modalTitle.style.backgroundClip = 'text';
                    
                    modal.classList.add('active');
                }
            });
        });

        const modal = document.getElementById('serviceModal');
        const modalClose = document.getElementById('modalClose');
        modalClose.addEventListener('click', () => { modal.classList.remove('active'); });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) { modal.classList.remove('active'); }
        });

    </script>
</body>
</html>


