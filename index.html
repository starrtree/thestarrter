<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Energy Canvas</title>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        :root {
            --gold-color: #ffc300;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { 
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        /* --- Service Nodes & Sub-Menu --- */
        .service-nodes-container, .submenu-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none; 
            transition: transform 0.2s ease-out; 
        }
        .service-node {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            
            transform: scale(0.2);
            opacity: 0;
            cursor: default;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* Glow effect using a blurred pseudo-element */
        .service-node::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            width: calc(100% + 10px);
            height: calc(100% + 10px);
            border-radius: 50%;
            filter: blur(10px);
            z-index: -1;
            opacity: 0.7;
            transition: opacity 0.3s ease, filter 0.3s ease;
        }
        /* Larger hover area */
        .service-node::before {
            content: '';
            position: absolute;
            top: -30px;
            left: -30px;
            width: 110px;
            height: 110px;
            background: transparent;
            border-radius: 50%;
        }

        .service-node.activated {
            transform: scale(1);
            opacity: 1;
            cursor: pointer;
            pointer-events: all;
            animation: pulse 2s infinite ease-in-out;
        }
        .service-node .icon {
            font-size: 22px;
            transition: all 0.3s ease;
        }
        .service-node .description {
            position: absolute;
            bottom: -45px;
            width: 220px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 8px, 0 0 12px;
            pointer-events: none; 
        }
        .service-node.activated:hover {
            transform: scale(1.1);
            animation-play-state: paused;
        }
        .service-node.activated:hover .icon {
            transform: scale(1.1);
        }
        .service-node.activated:hover .description {
            opacity: 1;
        }

        .service-node.activated:hover::after {
            opacity: 1;
            filter: blur(15px);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }


        /* --- Unique Node Colors & Gradients --- */
        .service-node {
            border-color: transparent;
            background-origin: border-box;
            background-clip: content-box, border-box;
        }

        #node-music {
            background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), linear-gradient(45deg, #39ff14, #ff00ff);
        }
        #node-music::after {
            background: linear-gradient(45deg, #39ff14, #ff00ff);
        }
        #node-music .icon, #node-music .description { color: #39ff14; }

        #node-ai {
            background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), linear-gradient(45deg, #8A2BE2, #00BFFF);
        }
        #node-ai::after {
            background: linear-gradient(45deg, #8A2BE2, #00BFFF);
        }
        #node-ai .icon, #node-ai .description { color: #00BFFF; }

        #node-design {
            background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), linear-gradient(45deg, #FF4500, #FF0000);
        }
        #node-design::after {
            background: linear-gradient(45deg, #FF4500, #FF0000);
        }
        #node-design .icon, #node-design .description { color: #FF4500; }

        #node-engineering {
            background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), linear-gradient(45deg, #0000FF, #FFFF00);
        }
        #node-engineering::after {
            background: linear-gradient(45deg, #0000FF, #FFFF00);
        }
        #node-engineering .icon, #node-engineering .description { color: #FFFF00; }


        /* Repositioning the nodes */
        #node-ai { top: 15%; left: 50%; transform: translateX(-50%) scale(0.2); }
        #node-music { bottom: 10%; left: 50%; transform: translateX(-50%) scale(0.2); }
        #node-design { top: 50%; right: 20%; transform: translateY(-50%) scale(0.2); }
        #node-engineering { top: 50%; left: 20%; transform: translateY(-50%) scale(0.2); }
        
        .service-node.activated#node-ai, .service-node.activated#node-music { animation-name: pulse-x; }
        .service-node.activated#node-design, .service-node.activated#node-engineering { animation-name: pulse-y; }
        
        .service-node.activated#node-ai:hover, .service-node.activated#node-music:hover { transform: translateX(-50%) scale(1.1); animation-name: none; }
        .service-node.activated#node-design:hover, .service-node.activated#node-engineering:hover { transform: translateY(-50%) scale(1.1); animation-name: none; }
        
        @keyframes pulse-x {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }
        @keyframes pulse-y {
            0% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.05); }
            100% { transform: translateY(-50%) scale(1); }
        }

        /* --- New Sub-Menu Styles --- */
        .submenu-item {
            position: absolute;
            color: var(--gold-color);
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px var(--gold-color);
            cursor: pointer;
            pointer-events: all;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.4s ease-out;
        }
        .submenu-item.visible {
            opacity: 1;
            transform: scale(1);
        }
        /* Repositioned sub-menu items */
        #submenu-creations { top: 30%; left: 50%; transform: translateX(-50%) scale(0.5); }
        #submenu-offerings { top: 70%; left: 50%; transform: translateX(-50%) scale(0.5); }
        #submenu-commune { bottom: 2%; left: 50%; transform: translateX(-50%) scale(0.5); }
        
        .submenu-item.visible#submenu-creations,
        .submenu-item.visible#submenu-offerings,
        .submenu-item.visible#submenu-commune {
            transform: translateX(-50%) scale(1);
        }


        /* --- Modal --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content {
            background: #0a0a0a;
            border: 3px solid var(--gold-color);
            width: 450px;
            height: 450px;
            max-width: 90vw;
            max-height: 90vw;
            border-radius: 50%;
            padding: 40px;
            box-sizing: border-box;
            color: #eee;
            box-shadow: 0 0 30px var(--gold-color);
            position: relative;
            transform: scale(0.9);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .modal.active .modal-content { transform: scale(1); }
        .modal-content h2 { 
            margin-top: 0; 
            margin-bottom: 15px;
            color: var(--gold-color); 
            transition: color 0.3s ease; 
        }
        .modal-content p {
            margin: 0;
            font-size: 15px;
            line-height: 1.5;
        }
        .modal-close {
            position: absolute;
            top: 20%;
            right: 20%;
            transform: translate(50%, -50%);
            font-size: 28px;
            color: #fff; cursor: pointer; transition: color 0.2s;
        }
        .modal-close:hover { color: #ffc300; }

        @media (max-width: 768px) {
            .service-node { width: 40px; height: 40px; }
            .service-node.activated .icon { font-size: 18px; }
            #node-ai { top: 10%; }
            #node-music { bottom: 5%; }
            #node-design { top: 50%; right: 5%; }
            #node-engineering { top: 50%; left: 5%; }
            .service-node .description { font-size: 12px; bottom: -35px; width: 150px; }
        }

    </style>
</head>
<body>
    <canvas id="cosmicCanvas"></canvas>

    <div class="service-nodes-container" id="nodesContainer">
        <div class="service-node" id="node-music" data-service="music">
            <div class="icon"><i class="fas fa-music"></i></div>
            <div class="description"></div>
        </div>
        <div class="service-node" id="node-ai" data-service="ai">
            <div class="icon"><i class="fas fa-robot"></i></div>
            <div class="description"></div>
        </div>
        <div class="service-node" id="node-design" data-service="design">
            <div class="icon"><i class="fas fa-paint-brush"></i></div>
            <div class="description"></div>
        </div>
        <div class="service-node" id="node-engineering" data-service="engineering">
            <div class="icon"><i class="fas fa-cogs"></i></div>
            <div class="description"></div>
        </div>
    </div>

    <!-- New Sub-Menu HTML -->
    <div class="submenu-container">
        <div class="submenu-item" id="submenu-creations">Creations</div>
        <div class="submenu-item" id="submenu-offerings">Offerings</div>
        <div class="submenu-item" id="submenu-commune">Commune</div>
    </div>

    <div class="modal" id="serviceModal">
        <div class="modal-content">
            <span class="modal-close" id="modalClose">&times;</span>
            <h2 id="modalTitle"></h2>
            <p id="modalDescription"></p>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('cosmicCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centralFigure = new Image();
        let imageFailedToLoad = false;
        centralFigure.crossOrigin = "Anonymous"; 
        centralFigure.onload = () => { run(); };
        centralFigure.onerror = () => { imageFailedToLoad = true; run(); };
        centralFigure.src = 'https://i.imgur.com/6lzWabU.png';

        let stars = [];
        let branches = [];
        let subMenuLines = [];
        const STAR_COUNT = 500; 
        const BRANCH_COUNT = 30;
        const GOLD_COLOR = '#ffc300';
        const DARK_GOLD_COLOR = '#ff9400';
        let nodeTargets = [];
        let globalScale = 1.0;
        const nodesContainer = document.getElementById('nodesContainer');
        let isDragging = false;
        let lastMouseX = 0; let lastMouseY = 0;
        let rotationX = 0; let rotationY = 0;
        let tugOffsetX = 0; let tugOffsetY = 0;
        let targetTugOffsetX = 0; let targetTugOffsetY = 0;

        let isIntroAnimationDone = false;
        const introDuration = 2500; 
        let introStartTime = null;
        let beamStartTime = null;
        const beamDuration = 600;

        let isHoveringFigure = false;
        let targetFigureScale = 1.0;
        let currentFigureExtraScale = 1.0;
        let isSubMenuOpen = false;
        const subMenuItems = Array.from(document.querySelectorAll('.submenu-item'));

        const serviceData = {
            music: { title: "Music", full: "My musical services are designed to give your project a polished, studio-quality sound. I offer custom theme song creation, a bespoke service for brands and individuals seeking a unique sonic signature. I also provide professionally engineered vocal presets for Bandlab, helping artists achieve a professional sound with ease." },
            ai: { title: "AI", full: "Harness the power of artificial intelligence. I specialize in building and configuring custom GPTs trained on your specific data and needs. From automating repetitive tasks to creating powerful new creative tools, I design AI solutions that harmonize technology and humanity." },
            design: { title: "Art/Digital Media", full: "Storytelling through image, motion, and experience. I offer creative services for artists and businesses, including the creation of compelling AI-powered video ads and mesmerizing music visualizers for your tracks. Let's bring your vision to life." },
            engineering: { title: "Engineering/Startups", full: "Building tools, systems, and futures. My engineering services cover web development on modern platforms and custom frontend work, as well as smart automation and creative problem-solving. I focus on building with intention to create beautiful and performant digital products." }
        };

        class Star {
            constructor() {
                this.radius3d = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.2);
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                this.x3d = this.radius3d * Math.sin(phi) * Math.cos(theta);
                this.y3d = this.radius3d * Math.sin(phi) * Math.sin(theta);
                this.z3d = this.radius3d * Math.cos(phi);
                this.originalRadius = Math.random() * 1.5 + 0.5;
            }
            project(rotX, rotY) {
                const cosY = Math.cos(rotY); const sinY = Math.sin(rotY);
                const cosX = Math.cos(rotX); const sinX = Math.sin(rotX);
                const tempX = this.x3d * cosY - this.z3d * sinY;
                const tempZ = this.x3d * sinY + this.z3d * cosY;
                const tempY = this.y3d * cosX - tempZ * sinX;
                this.rotatedZ = this.y3d * sinX + tempZ * cosX;
                this.rotatedX = tempX; this.rotatedY = tempY;
                const perspective = canvas.width * 0.8;
                const scale = perspective / (perspective + this.rotatedZ);
                this.screenX = canvas.width / 2 + this.rotatedX * scale;
                this.screenY = canvas.height / 2 + this.rotatedY * scale;
                this.screenRadius = this.originalRadius * scale;
                this.alpha = (this.rotatedZ + this.radius3d) / (this.radius3d * 2);
            }
            draw() {
                if (this.screenRadius < 0) return;
                ctx.beginPath();
                ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.fill();
            }
        }

        class Branch {
            constructor(staticX, staticY, angle, depth) {
                this.staticX = staticX;
                this.staticY = staticY;
                this.originX = staticX;
                this.originY = staticY;
                this.angle = angle;
                this.depth = depth;
                this.maxLength = Math.random() * 200 + 100 + (5 - depth) * 50;
                this.currentLength = 0;
                this.speed = (Math.random() * 1 + 0.5) * 1.5;
                this.lineWidth = Math.random() * 0.5 + (4 - depth) * 0.3;
                this.children = [];
                this.isGrown = false;

                this.oscillationRadius = Math.random() * 15 + 5;
                this.oscillationSpeed = (Math.random() * 0.5 + 0.5) * 0.001;
                this.oscillationOffset = Math.random() * Math.PI * 2;
            }
            update(timestamp) {
                if (this.depth === 2) { 
                    const angle = timestamp * this.oscillationSpeed + this.oscillationOffset;
                    this.originX = this.staticX + Math.cos(angle) * this.oscillationRadius;
                    this.originY = this.staticY + Math.sin(angle) * this.oscillationRadius;
                }
            }
            grow() {
                if (this.currentLength < this.maxLength) {
                    this.currentLength += this.speed;
                } else if (!this.isGrown) {
                    this.isGrown = true;
                    if (this.depth > 0) {
                        const endX = this.staticX + this.maxLength * Math.cos(this.angle);
                        const endY = this.staticY + this.maxLength * Math.sin(this.angle);
                        const angleOffset = Math.PI / (Math.random() * 4 + 4);
                        this.children.push(new Branch(endX, endY, this.angle - angleOffset, this.depth - 1));
                        this.children.push(new Branch(endX, endY, this.angle + angleOffset, this.depth - 1));
                    }
                }
                this.children.forEach(child => child.grow());
            }
            draw(startX, startY) {
                const endX = startX + this.currentLength * Math.cos(this.angle);
                const endY = startY + this.currentLength * Math.sin(this.angle);

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = GOLD_COLOR;
                ctx.stroke();

                this.children.forEach(child => child.draw(endX, endY));
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function checkNodeActivations(hoverOffset = 0) {
            const originX = canvas.width / 2 + tugOffsetX;
            const originY = canvas.height / 2 + hoverOffset + tugOffsetY;

            nodeTargets.forEach(target => {
                if (!target.isActivated) {
                    const rect = target.element.getBoundingClientRect();
                    const nodeX = rect.left + rect.width / 2;
                    const nodeY = rect.top + rect.height / 2;
                    const currentDistanceToNode = Math.sqrt(Math.pow(nodeX - originX, 2) + Math.pow(nodeY - originY, 2)) / globalScale;

                    const checkBranches = (branchList) => {
                        for (const branch of branchList) {
                            const branchDistFromOrigin = Math.sqrt(Math.pow(branch.originX-originX,2) + Math.pow(branch.originY-originY,2));
                            if (branch.currentLength + branchDistFromOrigin >= currentDistanceToNode) {
                                target.isActivated = true;
                                target.element.classList.add('activated');
                                return;
                            }
                            if (branch.children.length > 0) { checkBranches(branch.children); }
                        }
                    };
                    checkBranches(branches);
                }
            });
        }
        
        function startBranchGrowth() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            branches = [];
            for (let i = 0; i < BRANCH_COUNT; i++) {
                const angle = (Math.PI * 2 / BRANCH_COUNT) * i + (Math.random() - 0.5) * 0.1;
                const originRadius = Math.random() * 50 + 80;
                const branchOriginX = centerX + originRadius * Math.cos(angle);
                const branchOriginY = centerY + originRadius * Math.sin(angle);
                branches.push(new Branch(branchOriginX, branchOriginY, angle, 2));
            }
        }

        function init() {
            stars = []; branches = [];
            isIntroAnimationDone = false;
            introStartTime = null; beamStartTime = null;
            serviceNodes.forEach(node => node.classList.remove('activated'));
            for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            
            nodeTargets = [];
            serviceNodes.forEach(node => {
                nodeTargets.push({ element: node, isActivated: false });
            });
        }

        function animate(timestamp) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!isDragging) {
                rotationY += 0.0002;
            }

            stars.forEach(star => {
                star.project(rotationX, rotationY);
                star.draw();
            });
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const easeFactor = 0.05;
            tugOffsetX += (targetTugOffsetX - tugOffsetX) * easeFactor;
            tugOffsetY += (targetTugOffsetY - tugOffsetY) * easeFactor;
            currentFigureExtraScale += (targetFigureScale - currentFigureExtraScale) * easeFactor;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(globalScale, globalScale);
            ctx.translate(-centerX, -centerY);

            let currentFigureY = centerY;
            let currentFigureScale = 0.4;
            let easedProgress = 0;
            const hoverOffset = isIntroAnimationDone ? Math.sin(timestamp / 1500) * 10 : 0;
            const dynamicOriginX = centerX + tugOffsetX;
            const dynamicOriginY = centerY + hoverOffset + tugOffsetY;

            if (!isIntroAnimationDone) {
                if (introStartTime === null) introStartTime = timestamp;
                const elapsed = timestamp - introStartTime;
                const progress = Math.min(elapsed / introDuration, 1);
                easedProgress = easeInOutCubic(progress);

                const startY = canvas.height + 150;
                const endY = centerY;
                currentFigureY = startY - (startY - endY) * easedProgress;

                const startScale = 0.05;
                const endScale = 0.4;
                currentFigureScale = startScale + (endScale - startScale) * easedProgress;
                
                if (progress === 1) {
                    isIntroAnimationDone = true;
                    beamStartTime = timestamp;
                    startBranchGrowth();
                }
            } else {
                if (beamStartTime !== null) {
                    const beamElapsed = timestamp - beamStartTime;
                    const beamProgress = Math.min(beamElapsed / beamDuration, 1);
                    const currentBeamHeight = canvas.height * beamProgress;
                    const currentBeamWidth = canvas.width * beamProgress;

                    const vertGradient = ctx.createLinearGradient(centerX, 0, centerX, canvas.height);
                    vertGradient.addColorStop(0, 'rgba(255, 195, 0, 0)');
                    vertGradient.addColorStop(0.48, DARK_GOLD_COLOR);
                    vertGradient.addColorStop(0.52, DARK_GOLD_COLOR);
                    vertGradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
                    
                    const horizGradient = ctx.createLinearGradient(0, centerY, canvas.width, centerY);
                    horizGradient.addColorStop(0, 'rgba(255, 195, 0, 0)');
                    horizGradient.addColorStop(0.48, DARK_GOLD_COLOR);
                    horizGradient.addColorStop(0.52, DARK_GOLD_COLOR);
                    horizGradient.addColorStop(1, 'rgba(255, 195, 0, 0)');

                    ctx.save();
                    ctx.fillStyle = vertGradient;
                    ctx.shadowColor = GOLD_COLOR;
                    ctx.shadowBlur = 30;
                    ctx.fillRect(dynamicOriginX - 3, centerY - currentBeamHeight / 2, 6, currentBeamHeight);
                    
                    ctx.fillStyle = horizGradient;
                    ctx.fillRect(centerX - currentBeamWidth / 2, dynamicOriginY - 3, currentBeamWidth, 6);
                    ctx.restore();
                }
                
                ctx.save();
                ctx.shadowColor = GOLD_COLOR;
                ctx.shadowBlur = 10;
                branches.forEach(branch => { 
                    branch.update(timestamp);
                    branch.grow();
                    ctx.beginPath();
                    ctx.moveTo(dynamicOriginX, dynamicOriginY);
                    ctx.lineTo(branch.originX, branch.originY);
                    ctx.lineWidth = branch.lineWidth;
                    ctx.strokeStyle = GOLD_COLOR;
                    ctx.stroke();
                    branch.draw(branch.originX, branch.originY); 
                });
                
                if (isSubMenuOpen) {
                    subMenuItems.forEach(item => {
                        const rect = item.getBoundingClientRect();
                        const itemX = rect.left + rect.width / 2;
                        const itemY = rect.top + rect.height / 2;
                        ctx.beginPath();
                        ctx.moveTo(dynamicOriginX, dynamicOriginY);
                        ctx.lineTo(itemX, itemY);
                        ctx.stroke();
                    });
                }
                ctx.restore();
                checkNodeActivations(hoverOffset);
            }

            if (!imageFailedToLoad && centralFigure.complete) {
                const finalScale = currentFigureScale * currentFigureExtraScale;
                const figHeight = canvas.height * finalScale;
                const scale = figHeight / centralFigure.naturalHeight;
                const figWidth = centralFigure.naturalWidth * scale;
                
                const finalFigureCenterY = isIntroAnimationDone ? dynamicOriginY : currentFigureY;

                let glowStrength1, glowStrength2;
                if(isIntroAnimationDone) {
                    const pulse = (Math.sin(timestamp / 800) + 1) / 2; 
                    glowStrength1 = 10 + pulse * 15;
                    glowStrength2 = 25 + pulse * 30;
                    if(isHoveringFigure) {
                        glowStrength1 = 30;
                        glowStrength2 = 70;
                    }
                } else {
                    glowStrength1 = 15 * easedProgress;
                    glowStrength2 = 35 * easedProgress;
                }
                
                ctx.save();
                ctx.filter = `drop-shadow(0 0 ${glowStrength1}px ${GOLD_COLOR}) drop-shadow(0 0 ${glowStrength2}px ${DARK_GOLD_COLOR})`;
                ctx.drawImage(centralFigure, dynamicOriginX - figWidth / 2, finalFigureCenterY - figHeight / 2, figWidth, figHeight);
                ctx.restore();
            }
            
            ctx.restore();

            requestAnimationFrame(animate);
        }

        function run() {
            init();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const zoomAmount = e.deltaY * -zoomSpeed;
            const minScale = 0.5;
            const maxScale = 2.0;
            globalScale = Math.max(minScale, Math.min(maxScale, globalScale + zoomAmount));
            nodesContainer.style.transform = `scale(${globalScale})`;
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                const rotationSpeed = 0.002;
                rotationY += deltaX * rotationSpeed;
                rotationX += deltaY * rotationSpeed;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                const pullX = e.clientX - canvas.width / 2;
                const pullY = e.clientY - canvas.height / 2;
                const pullStrength = 0.15;
                targetTugOffsetX = pullX * pullStrength;
                targetTugOffsetY = pullY * pullStrength;
            }

            const figRect = {
                x: (canvas.width / 2 + tugOffsetX) - (centralFigure.naturalWidth * (canvas.height * 0.4 * currentFigureExtraScale) / centralFigure.naturalHeight)/2,
                y: (canvas.height / 2 + (isIntroAnimationDone ? Math.sin(Date.now() / 1500) * 10 : 0) + tugOffsetY) - (canvas.height * 0.4 * currentFigureExtraScale)/2,
                width: centralFigure.naturalWidth * (canvas.height * 0.4 * currentFigureExtraScale) / centralFigure.naturalHeight,
                height: canvas.height * 0.4 * currentFigureExtraScale
            };
            
            if (e.clientX > figRect.x && e.clientX < figRect.x + figRect.width &&
                e.clientY > figRect.y && e.clientY < figRect.y + figRect.height) {
                isHoveringFigure = true;
                targetFigureScale = 1.05;
            } else {
                isHoveringFigure = false;
                targetFigureScale = 1.0;
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            targetTugOffsetX = 0;
            targetTugOffsetY = 0;
        });
        
        canvas.addEventListener('click', (e) => {
            if(isHoveringFigure) {
                isSubMenuOpen = !isSubMenuOpen;
                subMenuItems.forEach(item => item.classList.toggle('visible', isSubMenuOpen));
            }
        });


        const modal = document.getElementById('serviceModal');
        const modalContent = modal.querySelector('.modal-content');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalClose = document.getElementById('modalClose');
        const serviceNodes = document.querySelectorAll('.service-node');

        serviceNodes.forEach(node => {
            const serviceKey = node.dataset.service;
            const descriptionEl = node.querySelector('.description');
            
            descriptionEl.textContent = serviceData[serviceKey].title;

            node.addEventListener('click', () => {
                if (!node.classList.contains('activated')) return; 
                const nodeStyle = window.getComputedStyle(node);
                const nodeBackgroundImage = nodeStyle.getPropertyValue('background-image');
                
                modalTitle.textContent = serviceData[serviceKey].title;
                modalDescription.textContent = serviceData[serviceKey].full;

                modalContent.style.backgroundImage = nodeBackgroundImage;
                modalContent.style.backgroundClip = 'border-box'; 
                modalContent.style.borderColor = 'transparent';

                modalTitle.style.background = nodeBackgroundImage.split(', ')[1];
                modalTitle.style.webkitBackgroundClip = 'text';
                modalTitle.style.webkitTextFillColor = 'transparent';
                modalTitle.style.backgroundClip = 'text';
                
                modal.classList.add('active');
            });
        });

        modalClose.addEventListener('click', () => { modal.classList.remove('active'); });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) { modal.classList.remove('active'); }
        });

    </script>
</body>
</html>