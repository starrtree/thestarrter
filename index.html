<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Energy Canvas</title>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        :root {
            --gold-color: #ffc300;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }
        canvas { 
            display: block; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }

        /* --- Modal --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.4s ease, visibility 0.4s ease; backdrop-filter: blur(5px);
        }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content {
            background: #0a0a0a;
            border: 2px solid var(--gold-color);
            width: 450px;
            height: 450px;
            max-width: 90vw;
            max-height: 90vw;
            border-radius: 50%;
            padding: 40px;
            box-sizing: border-box;
            color: #eee;
            box-shadow: 0 0 40px var(--gold-color), inset 0 0 15px rgba(255, 195, 0, 0.3);
            position: relative;
            transform: scale(0.8) rotate(-10deg);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .modal.active .modal-content { transform: scale(1) rotate(0deg); }
        .modal-content h2 { 
            margin-top: 0; 
            margin-bottom: 20px;
            font-size: 2.5rem;
            color: var(--gold-color); 
            transition: color 0.3s ease; 
        }
        .modal-content p {
            margin: 0;
            font-size: 16px;
            line-height: 1.6;
        }
        .modal-close {
            position: absolute;
            top: 22%;
            right: 22%;
            transform: translate(50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff; cursor: pointer; transition: color 0.2s, transform 0.2s;
        }
        .modal-close:hover { color: #ffc300; transform: translate(50%, -50%) scale(1.2); }
        
    </style>
</head>
<body>
    <canvas id="cosmicCanvas"></canvas>

    <div class="modal" id="serviceModal">
        <div class="modal-content">
            <span class="modal-close" id="modalClose">&times;</span>
            <h2 id="modalTitle"></h2>
            <p id="modalDescription"></p>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('cosmicCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centralFigureImage = new Image();
        let imageFailedToLoad = false;
        centralFigureImage.crossOrigin = "Anonymous"; 
        centralFigureImage.onload = () => { run(); };
        centralFigureImage.onerror = () => { imageFailedToLoad = true; run(); };
        centralFigureImage.src = 'https://i.imgur.com/Zclc7ji.png';

        let stars = [], renderables = [], particles = [], dust = [], shootingStars = [];
        let nebulaCanvas; 
        const STAR_COUNT = 500; 
        const DUST_COUNT = 100;
        const BRANCH_COUNT = 30;
        const GOLD_COLOR = '#ffc300';
        const DARK_GOLD_COLOR = '#ff9400';
        let globalScale = 1.0;
        let isDragging = false;
        let hasDragged = false;
        let lastMouseX = 0, lastMouseY = 0;
        let rotationX = 0, rotationY = 0;
        let tugOffsetX = 0, tugOffsetY = 0;
        let targetTugOffsetX = 0, targetTugOffsetY = 0;
        let isIntroAnimationDone = false;
        const introDuration = 2500; 
        let introStartTime = null;
        let beamStartTime = null;
        const beamDuration = 600;
        let isHoveringFigure = false;
        let targetFigureScale = 1.0;
        let currentFigureExtraScale = 1.0;
        let isSubMenuOpen = false;

        // --- STEP 1: Expand serviceData ---
        const serviceData = {
            music: { title: "Music", full: "My musical services are designed to give your project a polished, studio-quality sound. I offer custom theme song creation, a bespoke service for brands and individuals seeking a unique sonic signature. I also provide professionally engineered vocal presets for Bandlab, helping artists achieve a professional sound with ease." },
            ai: { title: "AI", full: "Harness the power of artificial intelligence. I specialize in building and configuring custom GPTs trained on your specific data and needs. From automating repetitive tasks to creating powerful new creative tools, I design AI solutions that harmonize technology and humanity." },
            design: { title: "Art", full: "Storytelling through image, motion, and experience. I offer creative services for artists and businesses, including the creation of compelling AI-powered video ads and mesmerizing music visualizers for your tracks. Let's bring your vision to life." },
            engineering: { title: "Engineering", full: "Building tools, systems, and futures. My engineering services cover web development on modern platforms and custom frontend work, as well as smart automation and creative problem-solving. I focus on building with intention to create beautiful and performant digital products." },
            media: { title: "Media", full: "Placeholder text for Media projects and services." },
            culture: { title: "Culture", full: "Placeholder text for Culture projects and services." },
            uni: { title: "U.N.I.", full: "Placeholder text for U.N.I. projects and services." },
            starrt: { title: "STARRT", full: "Placeholder text for STARRT projects and services." },
            legacy: { title: "Legacy", full: "Placeholder text for Legacy projects and services." }
        };
        
        // --- STEP 1: Expand serviceConfig to 9 nodes ---
        const nodeCount = 9;
        const serviceConfig = {
            'ai':          { theta: (Math.PI * 2 / nodeCount) * 0,  phi: Math.PI * 0.5,  colors: ['#00AADD', '#00FFFF'], icon: '\uf544' },
            'design':      { theta: (Math.PI * 2 / nodeCount) * 1,  phi: Math.PI * 0.5,  colors: ['#FF00FF', '#FFFF00'], icon: '\uf1fc' },
            'engineering': { theta: (Math.PI * 2 / nodeCount) * 2,  phi: Math.PI * 0.5,  colors: ['#4B4B4B', '#B87333'], icon: '\uf085' },
            'music':       { theta: (Math.PI * 2 / nodeCount) * 3,  phi: Math.PI * 0.5,  colors: ['#1DB954', '#8A2BE2'], icon: '\uf001' },
            // --- NEW: Unique color schemes for new nodes ---
            'media':       { theta: (Math.PI * 2 / nodeCount) * 4,  phi: Math.PI * 0.5,  colors: ['#FF6347', '#FFD700'], icon: '\uf03d' }, // Tomato & Gold
            'culture':     { theta: (Math.PI * 2 / nodeCount) * 5,  phi: Math.PI * 0.5,  colors: ['#DAA520', '#F4A460'], icon: '\uf1ce' }, // Goldenrod & Sandy Brown
            'uni':         { theta: (Math.PI * 2 / nodeCount) * 6,  phi: Math.PI * 0.5,  colors: ['#FFFFFF', '#87CEEB'], icon: '\uf549' }, // White & Sky Blue
            'starrt':      { theta: (Math.PI * 2 / nodeCount) * 7,  phi: Math.PI * 0.5,  colors: ['#FF4500', '#FF8C00'], icon: '\uf135' }, // OrangeRed & Dark Orange
            'legacy':      { theta: (Math.PI * 2 / nodeCount) * 8,  phi: Math.PI * 0.5,  colors: ['#C0C0C0', '#FFFAF0'], icon: '\uf1b3' }  // Silver & Floral White
        };
        // --- END STEP 1 ---

        function createNebula() {
            const size = 1024;
            let offscreenCanvas;
            let offscreenCtx;
            try {
                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = size; offscreenCanvas.height = size;
                offscreenCtx = offscreenCanvas.getContext('2d');
                if (!offscreenCtx) {
                    throw new Error("Could not get 2D context for nebula.");
                }
            } catch (e) {
                console.error("Failed to create offscreen canvas for nebula:", e);
                return null; 
            }

            const colors = ['#4a1c54', '#1f195e', '#133b6d'];
            offscreenCtx.fillStyle = '#000';
            offscreenCtx.fillRect(0, 0, size, size);
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * size, y = Math.random() * size;
                const radius = Math.random() * size / 3 + size / 5;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const grad = offscreenCtx.createRadialGradient(x, y, 0, x, y, radius);
                grad.addColorStop(0, color + '40');
                grad.addColorStop(1, color + '00');
                offscreenCtx.fillStyle = grad;
                offscreenCtx.fillRect(0, 0, size, size);
            }

            offscreenCtx.save();
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.font = `bold ${size/8}px 'Arial Black', sans-serif`;
            offscreenCtx.fillStyle = `rgba(255, 220, 150, 0.04)`;
            offscreenCtx.globalCompositeOperation = 'overlay';
            offscreenCtx.fillText('MAX STARR', size / 2, size / 2);
            offscreenCtx.restore();

            return offscreenCanvas;
        }

        class ShootingStar {
            constructor() {
                const isVertical = Math.random() > 0.5;
                if (isVertical) {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() > 0.5 ? -50 : canvas.height + 50;
                } else {
                    this.x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                }
                
                const angleToCenter = Math.atan2(canvas.height / 2 - this.y, canvas.width / 2 - this.x);
                const spread = Math.PI / 4;
                this.angle = angleToCenter + (Math.random() - 0.5) * spread;

                this.speed = Math.random() * 8 + 5;
                this.velX = Math.cos(this.angle) * this.speed;
                this.velY = Math.sin(this.angle) * this.speed;
                this.size = Math.random() * 1.5 + 0.5;
                this.life = 1;
                this.alive = true;
            }

            update() {
                this.x += this.velX;
                this.y += this.velY;
                this.life -= 0.01;
                if (this.life <= 0) {
                    this.alive = false;
                }
            }

            draw(ctx) {
                const tailLength = 15;
                const tailX = this.x - this.velX * tailLength;
                const tailY = this.y - this.velY * tailLength;
                const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.life})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(this.x, this.y);
                ctx.lineWidth = this.size;
                ctx.strokeStyle = gradient;
                ctx.stroke();
            }
        }

        class Star {
            constructor() {
                this.radius3d = Math.random() * (canvas.width * 1.2) + (canvas.width * 0.3);
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                this.x3d = this.radius3d * Math.sin(phi) * Math.cos(theta);
                this.y3d = this.radius3d * Math.sin(phi) * Math.sin(theta);
                this.z3d = this.radius3d * Math.cos(phi);
                this.originalRadius = Math.random() * 1.5 + 0.5;
            }
            project(rotX, rotY) {
                const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                const tempX1 = this.x3d * cosY - this.z3d * sinY;
                const tempZ1 = this.x3d * sinY + this.z3d * cosY;
                this.rotatedX = tempX1;
                this.rotatedY = this.y3d * cosX - tempZ1 * sinX;
                this.rotatedZ = this.y3d * sinX + tempZ1 * cosX;
                const perspective = canvas.width * 0.8;
                const scale = perspective / (perspective + this.rotatedZ);
                this.screenX = canvas.width / 2 + this.rotatedX * scale;
                this.screenY = canvas.height / 2 + this.rotatedY * scale;
                this.screenRadius = this.originalRadius * scale;
                this.alpha = (this.rotatedZ + this.radius3d) / (this.radius3d * 2);
            }
            draw() {
                if (this.screenRadius < 0) return;
                ctx.beginPath();
                ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.fill();
            }
        }

        class CosmicDust extends Star {
            constructor() {
                super();
                this.radius3d = Math.random() * (canvas.width * 0.5) + (canvas.width * 0.1);
                this.originalRadius = Math.random() * 0.8 + 0.2;
                this.color = `hsl(${Math.random() * 60 + 200}, 100%, 80%)`;
            }
            draw() {
                if (this.screenRadius < 0) return;
                ctx.beginPath();
                ctx.arc(this.screenX, this.screenY, this.screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha * 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        class Node extends Star {
            constructor(serviceKey, config) {
                super();
                // --- FIX: Reduced radius to bring nodes closer to center ---
                this.baseRadius3d = canvas.width * 0.25;
                this.theta = config.theta; this.phi = config.phi;
                this.originalRadius = 30;
                this.serviceKey = serviceKey;
                this.colors = config.colors; this.icon = config.icon;
                this.isActivated = false; this.isHovered = false; this.activationProgress = 0;
                
                if(this.serviceKey === 'ai') {
                    this.particles = [];
                }
            }
            project(rotX, rotY, zoomScale) {
                this.radius3d = this.baseRadius3d * (1 + (zoomScale - 1) * 0.4); 
                this.x3d = this.radius3d * Math.sin(this.phi) * Math.cos(this.theta);
                this.y3d = this.radius3d * Math.sin(this.phi) * Math.sin(this.theta);
                this.z3d = this.radius3d * Math.cos(this.phi);
                super.project(rotX, rotY);
                this.screenRadius *= (1 + (zoomScale - 1) * 0.1);
            }
            draw(timestamp) {
                if (this.activationProgress < 1 && this.isActivated) this.activationProgress += 0.05;
                const currentScale = easeInOutCubic(this.activationProgress);
                if (!this.isActivated || this.screenRadius < 0) return;
                const pulse = this.isHovered ? 1.1 : 1 + Math.sin(timestamp / 500) * 0.05;
                const finalRadius = this.screenRadius * currentScale * pulse;

                ctx.save();

                // --- No changes to drawing logic, it will just use the config passed in ---
                if (this.serviceKey === 'engineering' || this.serviceKey === 'uni') { // Eng-style
                    const rotation = timestamp * 0.0003;
                    ctx.strokeStyle = this.colors[1]; // Copper
                    ctx.lineWidth = 1.5;
                    const dodecRadius = finalRadius * 1.2;
                    
                    const drawPentagon = (radius, rotOffset) => {
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (Math.PI * 2 / 5) * i + rotOffset;
                            const x = this.screenX + Math.cos(angle) * radius;
                            const y = this.screenY + Math.sin(angle) * radius;
                            if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    };
                    drawPentagon(dodecRadius, rotation);
                    drawPentagon(dodecRadius * 0.65, rotation + Math.PI);
                    
                    const metalGradient = ctx.createRadialGradient(this.screenX - finalRadius * 0.3, this.screenY - finalRadius * 0.3, finalRadius * 0.1, this.screenX, this.screenY, finalRadius);
                    metalGradient.addColorStop(0, '#CCCCCC');
                    metalGradient.addColorStop(1, this.colors[0]);
                    ctx.fillStyle = metalGradient;
                    ctx.beginPath(); ctx.arc(this.screenX, this.screenY, finalRadius, 0, Math.PI * 2); ctx.fill();

                } else { // All other nodes
                    const bodyGradient = ctx.createRadialGradient(this.screenX - finalRadius * 0.2, this.screenY - finalRadius * 0.2, finalRadius * 0.1, this.screenX, this.screenY, finalRadius);
                    bodyGradient.addColorStop(0, this.colors[0]); bodyGradient.addColorStop(1, this.colors[1]);
                    ctx.fillStyle = bodyGradient; ctx.beginPath(); ctx.arc(this.screenX, this.screenY, finalRadius, 0, Math.PI * 2); ctx.fill();
                }

                const highlightGradient = ctx.createRadialGradient(this.screenX - finalRadius * 0.4, this.screenY - finalRadius * 0.4, 0, this.screenX, this.screenY, finalRadius);
                highlightGradient.addColorStop(0, 'rgba(255,255,255,0.3)'); highlightGradient.addColorStop(0.5, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlightGradient; ctx.fill();
                
                if (this.serviceKey === 'ai' || this.serviceKey === 'media') { // AI-style
                    ctx.strokeStyle = this.colors[1] + '40';
                    ctx.lineWidth = 1;
                    for(let i=1; i < 5; i++) {
                        ctx.beginPath();
                        ctx.arc(this.screenX, this.screenY, finalRadius * (i/5), 0, Math.PI*2);
                        ctx.stroke();
                    }

                    // Only AI gets particles
                    if(this.serviceKey === 'ai') {
                        if(Math.random() > 0.8) this.particles.push({x:0, y:0, z:0, life: 1});
                        this.particles.forEach(p => {
                            p.x += (Math.random() - 0.5) * 0.1;
                            p.y += (Math.random() - 0.5) * 0.1;
                            p.z += (Math.random() - 0.5) * 0.1;
                            p.life -= 0.02;
                        });
                        this.particles = this.particles.filter(p => p.life > 0);
                        this.particles.forEach(p => {
                            const pRadius = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
                            const pScale = finalRadius * (1 + pRadius);
                            ctx.beginPath();
                            ctx.arc(this.screenX + p.x * pScale, this.screenY + p.y * pScale, p.life * 2, 0, Math.PI*2);
                            ctx.fillStyle = this.colors[1] + Math.round(p.life * 255).toString(16).padStart(2,'0');
                            ctx.fill();
                        });
                    }
                }
                
                if (this.serviceKey === 'music' || this.serviceKey === 'starrt') { // Music-style
                    const waveCount = 3;
                    const waveSpacing = 30 * (finalRadius / 35);
                    const pulseFactor = (timestamp * 0.0015) % 1;

                    for (let i = 0; i < waveCount; i++) {
                        const progress = (pulseFactor + i / waveCount) % 1;
                        const radius = finalRadius + progress * waveSpacing;
                        const opacity = Math.sin(progress * Math.PI) * 0.8;

                        ctx.beginPath();
                        ctx.arc(this.screenX, this.screenY, radius, 0, Math.PI * 2);
                        ctx.strokeStyle = this.colors[1] + Math.round(opacity * 255).toString(16).padStart(2, '0');
                        ctx.lineWidth = 2.5 * (1 - progress);
                        ctx.stroke();
                    }
                }
                
                // --- NEW: Unique visual effects for new nodes ---
                if (this.serviceKey === 'media') {
                    // Pulsing/flickering inner glow
                    const pulse = Math.abs(Math.sin(timestamp * 0.005));
                    ctx.beginPath();
                    ctx.arc(this.screenX, this.screenY, finalRadius * (0.6 + pulse * 0.2), 0, Math.PI * 2);
                    ctx.fillStyle = this.colors[1] + '80';
                    ctx.fill();
                }

                if (this.serviceKey === 'uni') {
                    // Sharp, bright star-like flare
                    const flarePoints = 4;
                    ctx.strokeStyle = this.colors[1] + 'A0';
                    ctx.lineWidth = 2.5;
                    for (let i = 0; i < flarePoints; i++) {
                        const angle = (Math.PI * 2 / flarePoints) * i + (timestamp * 0.0005);
                        const length = finalRadius * 1.3;
                        ctx.beginPath();
                        ctx.moveTo(this.screenX, this.screenY);
                        ctx.lineTo(this.screenX + Math.cos(angle) * length, this.screenY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                }

                if (this.serviceKey === 'legacy') {
                    // Simple, elegant, slow-pulsing outer ring
                    const pulse = (Math.sin(timestamp * 0.0008) + 1) / 2; // Slow pulse
                    ctx.strokeStyle = this.colors[0] + 'C0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.screenX, this.screenY, finalRadius * (1.1 + pulse * 0.15), 0, Math.PI * 2);
                    ctx.stroke();
                }
                // --- END NEW EFFECTS ---


                ctx.font = `900 ${finalRadius * 0.8}px "Font Awesome 5 Free"`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

                if (this.serviceKey === 'design' || this.serviceKey === 'culture') { // Design-style
                    const glitchAmount = finalRadius * 0.1;
                    const timeSeed = timestamp * 0.01;
                    
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(255, 0, 255, 0.8)`;
                    ctx.fillText(this.icon, this.screenX + Math.sin(timeSeed) * glitchAmount, this.screenY);
                    ctx.fillStyle = `rgba(0, 255, 255, 0.8)`;
                    ctx.fillText(this.icon, this.screenX - Math.sin(timeSeed) * glitchAmount, this.screenY);
                    
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    for(let i=0; i < finalRadius * 2; i+=4) {
                       ctx.fillRect(this.screenX - finalRadius, this.screenY - finalRadius + i, finalRadius * 2, 2);
                    }
                }

                // --- Icon Coloring ---
                if (this.serviceKey === 'engineering' || this.serviceKey === 'uni') ctx.fillStyle = this.colors[1];
                else if (this.serviceKey === 'music' || this.serviceKey === 'starrt') ctx.fillStyle = this.colors[1];
                else if (this.serviceKey === 'ai' || this.serviceKey === 'media') ctx.fillStyle = this.colors[1];
                else if (this.serviceKey === 'design' || this.serviceKey === 'culture') ctx.fillStyle = '#FFFFFF';
                else if (this.serviceKey === 'legacy') ctx.fillStyle = this.colors[0];
                else ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                
                ctx.fillText(this.icon, this.screenX, this.screenY);
                
                ctx.restore();

                if (this.isHovered) {
                    ctx.font = `bold ${finalRadius * 0.5}px Segoe UI`;
                    ctx.fillStyle = '#ffffff'; ctx.shadowColor = this.colors[0]; ctx.shadowBlur = 10;
                    ctx.fillText(serviceData[this.serviceKey].title, this.screenX, this.screenY + finalRadius * 1.5);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        class Figure {
             constructor() { this.rotatedZ = 0; }
             project(rotX, rotY, zoomScale) { 
                this.rotatedZ = 0; 
             }
             draw(timestamp, dynamicOriginX, dynamicOriginY, currentFigureScale, introProgress, zoomScale) {
                if (imageFailedToLoad || !centralFigureImage.complete) return;
                
                const parallaxFactor = 0.1; 
                const effectiveZoom = 1 + (zoomScale - 1) * parallaxFactor;
                const finalScale = currentFigureScale * currentFigureExtraScale * effectiveZoom;
                
                const figHeight = canvas.height * finalScale;
                const figWidth = centralFigureImage.naturalWidth * (figHeight / centralFigureImage.naturalHeight);
                let glowStrength1, glowStrength2;
                if(isIntroAnimationDone) {
                    const pulse = (Math.sin(timestamp / 800) + 1) / 2; 
                    glowStrength1 = 10 + pulse * 15;
                    glowStrength2 = 25 + pulse * 30;
                    if(isHoveringFigure) { glowStrength1 = 30; glowStrength2 = 70; }
                } else {
                    glowStrength1 = 15 * introProgress;
                    glowStrength2 = 35 * introProgress;
                }
                ctx.save();
                ctx.filter = `drop-shadow(0 0 ${glowStrength1}px ${GOLD_COLOR}) drop-shadow(0 0 ${glowStrength2}px ${DARK_GOLD_COLOR})`;
                ctx.drawImage(centralFigureImage, dynamicOriginX - figWidth / 2, dynamicOriginY - figHeight / 2, figWidth, figHeight);
                ctx.restore();
            }
        }

        class Branch {
            constructor(staticX, staticY, angle, depth, parent = null) {
                this.staticX = staticX; this.staticY = staticY;
                this.originX = staticX; this.originY = staticY;
                this.angle = angle; this.depth = depth;
                this.parent = parent;
                this.maxLength = Math.random() * 200 + 100 + (5 - depth) * 50;
                this.currentLength = 0;
                this.speed = (Math.random() * 1 + 0.5) * 1.5;
                this.lineWidth = Math.random() * 0.5 + (4 - depth) * 0.3;
                this.children = [];
                this.isGrown = false;
                this.oscillationRadius = Math.random() * 15 + 5;
                this.oscillationSpeed = (Math.random() * 0.5 + 0.5) * 0.001;
                this.oscillationOffset = Math.random() * Math.PI * 2;
                this.endX = this.originX;
                this.endY = this.originY;
            }
            update(timestamp) {
                if (this.depth === 2) { 
                    const angle = timestamp * this.oscillationSpeed + this.oscillationOffset;
                    this.originX = this.staticX + Math.cos(angle) * this.oscillationRadius;
                    this.originY = this.staticY + Math.sin(angle) * this.oscillationRadius;
                }
                this.endX = this.originX + this.currentLength * Math.cos(this.angle);
                this.endY = this.originY + this.currentLength * Math.sin(this.angle);
                this.children.forEach(child => child.update(timestamp));
            }
            grow() {
                if (this.currentLength < this.maxLength) {
                    this.currentLength += this.speed;
                } else if (!this.isGrown) {
                    this.isGrown = true;
                    if (this.depth > 0) {
                        const angleOffset = Math.PI / (Math.random() * 4 + 4);
                        this.children.push(new Branch(this.endX, this.endY, this.angle - angleOffset, this.depth - 1, this));
                        this.children.push(new Branch(this.endX, this.endY, this.angle + angleOffset, this.depth - 1, this));
                    }
                }
                this.children.forEach(child => child.grow());
            }
            draw(startX, startY) {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = GOLD_COLOR;
                ctx.stroke();
                this.children.forEach(child => child.draw(this.endX, this.endY));
            }
        }

        class EnergyWeb {
            constructor() { 
                this.rotatedZ = 1000; 
                this.branches = []; 
            }
            project() { this.rotatedZ = 1000; }
            startGrowth() {
                const centerX = canvas.width / 2, centerY = canvas.height / 2;
                this.branches = [];
                for (let i = 0; i < BRANCH_COUNT; i++) {
                    const angle = (Math.PI * 2 / BRANCH_COUNT) * i + (Math.random() - 0.5) * 0.1;
                    const originRadius = (Math.random() * 50 + 80);
                    const branchOriginX = centerX + originRadius * Math.cos(angle);
                    const branchOriginY = centerY + originRadius * Math.sin(angle);
                    this.branches.push(new Branch(branchOriginX, branchOriginY, angle, 2));
                }
            }
            draw(timestamp, dynamicOriginX, dynamicOriginY, zoomScale) {
                ctx.save();
                ctx.translate(dynamicOriginX, dynamicOriginY);
                ctx.scale(zoomScale, zoomScale);
                ctx.translate(-dynamicOriginX, -dynamicOriginY);

                ctx.shadowColor = GOLD_COLOR;
                ctx.shadowBlur = 10;
                this.branches.forEach(branch => { 
                    branch.update(timestamp);
                    branch.grow();
                    ctx.beginPath();
                    ctx.moveTo(dynamicOriginX, dynamicOriginY);
                    ctx.lineTo(branch.originX, branch.originY);
                    ctx.lineWidth = branch.lineWidth;
                    ctx.strokeStyle = GOLD_COLOR;
                    ctx.stroke();
                    branch.draw(branch.originX, branch.originY); 
                });
                
                ctx.restore();
            }
        }

        class PlantSubMenu {
            constructor(text, color, angle, action) {
                this.text = text;
                this.color = color;
                this.angle = angle;
                this.action = action;
                this.rotatedZ = 1; 
                this.currentLength = 0;
                this.maxLength = 140;
                this.speed = 4;
                this.screenX = 0;
                this.screenY = 0;
                this.isHovered = false;
                this.scale = 1; 
            }
            project(rotX, rotY, zoomScale) { 
                const parallaxFactor = 0.5; 
                const effectiveLength = this.maxLength * (1 + (zoomScale - 1) * parallaxFactor);

                this.x3d = effectiveLength * Math.cos(this.angle);
                this.y3d = effectiveLength * Math.sin(this.angle);
                this.z3d = 50; 
                
                const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                const tempX1 = this.x3d * cosY - this.z3d * sinY;
                const tempZ1 = this.x3d * sinY + this.z3d * cosY;
                this.rotatedX = tempX1;
                this.rotatedY = this.y3d * cosX - tempZ1 * sinX;
                this.rotatedZ = this.y3d * sinX + tempZ1 * cosX;
                
                const perspective = canvas.width * 0.8;
                const scale = perspective / (perspective + this.rotatedZ);
                this.screenX = canvas.width / 2 + this.rotatedX * scale;
                this.screenY = canvas.height / 2 + this.rotatedY * scale;
                this.scale = scale; 
            }
            isMouseOver(mouseX, mouseY) {
                if (this.currentLength < this.maxLength || this.scale < 0) return false;
                const textWidth = ctx.measureText(this.text).width * this.scale;
                const textHeight = 20 * this.scale; 
                return mouseX > this.screenX - textWidth / 2 && mouseX < this.screenX + textWidth / 2 &&
                       mouseY > this.screenY - textHeight / 2 && mouseY < this.screenY + textHeight / 2;
            }
            draw(timestamp, originX, originY, isOpen, zoomScale) {
                if (isOpen && this.currentLength < this.maxLength) this.currentLength += this.speed;
                else if (!isOpen && this.currentLength > 0) this.currentLength -= this.speed * 1.5;
                this.currentLength = Math.max(0, this.currentLength);
                const growthProgress = this.currentLength / this.maxLength;
                const opacity = easeInOutCubic(growthProgress);

                if (opacity > 0 && this.scale > 0) {
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    const segments = 20;
                    let lastX = originX;
                    let lastY = originY;
                    for (let i = 1; i <= segments; i++) {
                        const progress = i / segments;
                        if (progress > growthProgress) break;
                        
                        const currentX = lerp(originX, this.screenX, progress);
                        const currentY = lerp(originY, this.screenY, progress);
                        
                        const angleToEndpoint = Math.atan2(this.screenY - originY, this.screenX - originX);
                        const wobble = Math.sin(progress * Math.PI * 2 + timestamp * 0.001) * 5 * progress * this.scale;
                        const x = currentX + wobble * Math.cos(angleToEndpoint + Math.PI/2);
                        const y = currentY + wobble * Math.sin(angleToEndpoint + Math.PI/2);
                        ctx.lineTo(x, y);

                        if (i > 2 && i % 3 === 0) {
                            const leafAngle = angleToEndpoint + (Math.PI/4 * (i % 2 === 0 ? -1 : 1)) + Math.sin(timestamp * 0.001 + i) * 0.2;
                            const leafLength = 20 * this.scale * growthProgress;
                            const leafWidth = 8 * this.scale * growthProgress;

                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate(leafAngle);
                            ctx.beginPath();
                            ctx.moveTo(0,0);
                            ctx.quadraticCurveTo(leafLength/2, -leafWidth, leafLength, 0);
                            ctx.quadraticCurveTo(leafLength/2, leafWidth, 0, 0);
                            ctx.fillStyle = '#6B8E23';
                            ctx.fill();
                            ctx.restore();
                        }

                        lastX = x;
                        lastY = y;
                    }
                    this.screenX = lastX;
                    this.screenY = lastY;

                    ctx.strokeStyle = '#553E2D';
                    ctx.lineWidth = 3 * this.scale;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    const fontSize = 18 * this.scale;
                    ctx.font = `bold ${fontSize}px Segoe UI`;
                    ctx.fillStyle = this.isHovered ? '#FFFFFF' : '#ADFF2F'; // Green-Yellow
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 5;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, this.screenX, this.screenY);
                    ctx.restore();
                }
            }
        }

        class Particle {
            constructor(x, y, targetBranch) {
                this.x = x; this.y = y; this.targetBranch = targetBranch;
                this.progress = 0; 
                this.speed = (Math.random() * 0.3 + 0.2) * 0.01;
                this.lifespan = 1; this.radius = Math.random() * 1.2;
            }
            update() {
                this.progress += this.speed; this.lifespan -= 0.005;
                const targetX = this.targetBranch.originX;
                const targetY = this.targetBranch.originY;
                const startX = canvas.width / 2 + tugOffsetX;
                const startY = canvas.height / 2 + tugOffsetY;
                this.x = startX + (targetX - startX) * this.progress;
                this.y = startY + (targetY - startY) * this.progress;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 220, 150, ${this.lifespan})`;
                ctx.fill();
            }
        }

        function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
        
        function lerp(start, end, t) { return start * (1 - t) + end * t; } // --- NEW: Added lerp function ---

        function checkNodeActivations(hoverOffset = 0) {
            const originX = canvas.width / 2 + tugOffsetX;
            const originY = canvas.height / 2 + hoverOffset + tugOffsetY;
            const energyWeb = renderables.find(r => r instanceof EnergyWeb);
            if (!energyWeb) return;

            renderables.forEach(r => {
                if (r instanceof Node && !r.isActivated) {
                    if (typeof r.x3d === 'number' && typeof r.y3d === 'number' && typeof r.z3d === 'number') {
                        const nodeDist3D = Math.sqrt(r.x3d**2 + r.y3d**2 + r.z3d**2);
                        const checkBranches = (branchList) => {
                            for (const branch of branchList) {
                                const branchDistFromOrigin = Math.sqrt(Math.pow(branch.originX-originX,2) + Math.pow(branch.originY-originY,2));
                                if (branch.currentLength + branchDistFromOrigin >= nodeDist3D) {
                                    r.isActivated = true;
                                    return;
                                }
                                if (branch.children.length > 0) { checkBranches(branch.children); }
                            }
                        };
                        checkBranches(energyWeb.branches);
                    }
                }
            });
        }
        
        function init() {
            stars = []; renderables = []; particles = []; dust = []; shootingStars = [];
            isIntroAnimationDone = false;
            introStartTime = null; beamStartTime = null;
            
            nebulaCanvas = createNebula();
            if (!nebulaCanvas) {
                console.error("Initialization failed: Could not create nebula canvas.");
                return false; 
            }

            for (let i = 0; i < STAR_COUNT; i++) { stars.push(new Star()); }
            for (let i = 0; i < DUST_COUNT; i++) { dust.push(new CosmicDust()); }

            const nodes = Object.keys(serviceConfig).map(key => new Node(key, serviceConfig[key]));
            const figure = new Figure();
            const energyWeb = new EnergyWeb();

            const subMenuItems = [
                new PlantSubMenu('Creations', '', -Math.PI / 2, 'creations'),
                new PlantSubMenu('Offerings', '', Math.PI * 1/6, 'offerings'),
                new PlantSubMenu('Commune', '', Math.PI * 5/6, 'commune')
            ];

            renderables = [...nodes, figure, energyWeb, ...subMenuItems];
            return true; 
        }

        function animate(timestamp) {
            if (!nebulaCanvas || !nebulaCanvas.width || !nebulaCanvas.height) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                console.error("Animate loop running without a valid nebulaCanvas.");
                requestAnimationFrame(animate); 
                return;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!isDragging) rotationY += 0.0006;
            
            ctx.save();
            ctx.globalAlpha = 0.5;
            const nebulaRotation = timestamp * 0.00002;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rotationY / 5 + nebulaRotation);
            ctx.drawImage(nebulaCanvas, -nebulaCanvas.width, -nebulaCanvas.height, nebulaCanvas.width * 2, nebulaCanvas.height * 2);
            ctx.restore();

            if (Math.random() > 0.992 && shootingStars.length < 3) {
                shootingStars.push(new ShootingStar());
            }
            shootingStars.forEach(s => { if (s && typeof s.update === 'function') s.update(); });
            shootingStars = shootingStars.filter(s => s && s.alive);
            shootingStars.forEach(s => { if (s && typeof s.draw === 'function') s.draw(ctx); });


            stars.forEach(star => { 
                if (star && typeof star.project === 'function') {
                    star.project(rotationX, rotationY); 
                    if (typeof star.draw === 'function') star.draw(); 
                }
            });
            dust.forEach(d => { 
                if (d && typeof d.project === 'function') {
                    d.project(rotationX * 0.5, rotationY * 0.5); 
                    if (typeof d.draw === 'function') d.draw();
                }
            });
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const easeFactor = 0.05;
            tugOffsetX += (targetTugOffsetX - tugOffsetX) * easeFactor;
            tugOffsetY += (targetTugOffsetY - tugOffsetY) * easeFactor;
            currentFigureExtraScale += (targetFigureScale - currentFigureExtraScale) * easeFactor;
            
            const hoverOffset = isIntroAnimationDone ? Math.sin(timestamp / 1500) * 10 : 0;
            const dynamicOriginX = centerX + tugOffsetX;
            const dynamicOriginY = centerY + hoverOffset + tugOffsetY;

            let currentFigureY = centerY;
            let currentFigureScale = 0.5;
            let easedProgress = 0;
            const energyWeb = renderables.find(r => r instanceof EnergyWeb);

            if (!isIntroAnimationDone) {
                if (introStartTime === null) introStartTime = timestamp;
                const elapsed = timestamp - introStartTime;
                const progress = Math.min(elapsed / introDuration, 1);
                easedProgress = easeInOutCubic(progress);
                currentFigureY = lerp(canvas.height + 150, centerY, easedProgress); // Use lerp
                currentFigureScale = lerp(0.05, 0.5, easedProgress); // Use lerp
                if (progress === 1) {
                    isIntroAnimationDone = true;
                    beamStartTime = timestamp;
                    if(energyWeb && typeof energyWeb.startGrowth === 'function') {
                        energyWeb.startGrowth(); 
                    }
                }
            }
            
            const figure = renderables.find(r => r instanceof Figure);
            let figScreenX = dynamicOriginX;
            let figScreenY = isIntroAnimationDone ? dynamicOriginY : currentFigureY;

            renderables.forEach(r => { 
                if(r && typeof r.project === 'function') {
                    if (r instanceof Figure) {
                        r.project(rotationX, rotationY, globalScale);
                        if (isFinite(r.screenX) && isFinite(r.screenY)) {
                            figScreenX = r.screenX + tugOffsetX;
                            figScreenY = (isIntroAnimationDone ? r.screenY + tugOffsetY + hoverOffset : currentFigureY);
                        }
                    } else if (r instanceof PlantSubMenu) {
                         // Defer
                    } else {
                        r.project(rotationX, rotationY, globalScale); 
                    }
                }
            });

            renderables.forEach(r => {
                if (r instanceof PlantSubMenu && typeof r.project === 'function') {
                    r.project(rotationX, rotationY, globalScale);
                }
            });
            
            renderables.sort((a,b) => (b.rotatedZ ?? -Infinity) - (a.rotatedZ ?? -Infinity)); 
            
            if (isIntroAnimationDone) {
                if (beamStartTime !== null) {
                    // ... beam drawing logic ...
                }
                
                if (energyWeb && energyWeb.branches && typeof energyWeb.branches.length !== 'undefined' && Math.random() > 0.9) {
                    // ... particle creation logic ...
                }
                checkNodeActivations(hoverOffset);
            }
            
            // Unified Render Loop
            renderables.forEach(r => {
                if (!r || typeof r.draw !== 'function') return;

                if (r instanceof EnergyWeb && isIntroAnimationDone) {
                    r.draw(timestamp, dynamicOriginX, dynamicOriginY, globalScale);
                } else if (r instanceof Figure) {
                   r.draw(timestamp, dynamicOriginX, isIntroAnimationDone ? dynamicOriginY : currentFigureY, currentFigureScale, easedProgress, globalScale);
                } else if (r instanceof Node) {
                    r.draw(timestamp);
                } else if (r instanceof PlantSubMenu) { 
                    r.draw(timestamp, figScreenX, figScreenY, isSubMenuOpen, globalScale);
                }
            });

            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if(p.lifespan <= 0) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        function run() {
            const initSuccess = init();
            if (initSuccess) {
                requestAnimationFrame(animate);
            } else {
                console.error("Run failed: Initialization was not successful.");
                if (ctx) {
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText("Error: Could not initialize graphics. Please refresh.", canvas.width / 2, canvas.height / 2);
                }
            }
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            run(); 
        });

        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const zoomAmount = e.deltaY * -zoomSpeed;
            const minScale = 0.5;
            const maxScale = 3.0; 
            globalScale = Math.max(minScale, Math.min(maxScale, globalScale + zoomAmount));
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            hasDragged = false;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                  hasDragged = true;
                }

                const rotationSpeed = 0.002;
                rotationY += deltaX * rotationSpeed;
                rotationX += deltaY * rotationSpeed;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                const pullX = e.clientX - canvas.width / 2;
                const pullY = e.clientY - canvas.height / 2;
                const pullStrength = 0.15;
                targetTugOffsetX = pullX * pullStrength;
                targetTugOffsetY = pullY * pullStrength;
            }

            let handledByNode = false;
            renderables.forEach(r => {
                if (r instanceof Node) {
                    const dist = Math.sqrt((e.clientX - r.screenX)**2 + (e.clientY - r.screenY)**2);
                    if (r.isActivated && dist < r.screenRadius * 1.2) {
                        r.isHovered = true;
                        handledByNode = true;
                    } else {
                        r.isHovered = false;
                    }
                }
            });

            let handledBySubMenu = false;
            renderables.forEach(r => {
                if (r instanceof PlantSubMenu) {
                    if (r && typeof r.isMouseOver === 'function' && r.isMouseOver(e.clientX, e.clientY)) {
                        r.isHovered = true;
                        handledBySubMenu = true;
                    } else if (r) {
                        r.isHovered = false;
                    }
                }
            });
            
            const fig = renderables.find(r => r instanceof Figure);
            if (fig) { 
                const scaledFigHeight = canvas.height * 0.5 * currentFigureExtraScale * globalScale; 
                const scaledFigWidth = (centralFigureImage.naturalWidth || 1) * (scaledFigHeight / (centralFigureImage.naturalHeight || 1));
                if (isFinite(fig.screenX) && isFinite(fig.screenY)) {
                    const figRect = {
                        x: (fig.screenX + tugOffsetX) - scaledFigWidth/2, 
                        y: (fig.screenY + tugOffsetY + (isIntroAnimationDone ? Math.sin(Date.now() / 1500) * 10 : 0)) - scaledFigHeight/2,
                        width: scaledFigWidth,
                        height: scaledFigHeight
                    };
                    
                    if (!handledByNode && isIntroAnimationDone && e.clientX > figRect.x && e.clientX < figRect.x + figRect.width &&
                        e.clientY > figRect.y && e.clientY < figRect.y + figRect.height) {
                        isHoveringFigure = true;
                        targetFigureScale = 1.05;
                    } else {
                        isHoveringFigure = false;
                        targetFigureScale = 1.0;
                    }
                } else {
                    isHoveringFigure = false;
                    targetFigureScale = 1.0;
                }
            } else {
                isHoveringFigure = false;
                targetFigureScale = 1.0;
            }

            canvas.style.cursor = isHoveringFigure || handledByNode || handledBySubMenu ? 'pointer' : (isDragging ? 'grabbing' : 'grab');
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            targetTugOffsetX = 0;
            targetTugOffsetY = 0;
        });
        
        canvas.addEventListener('click', (e) => {
             if (hasDragged) return;

            if(isHoveringFigure) {
                isSubMenuOpen = !isSubMenuOpen;
            }

            let subMenuItemClicked = false;
            renderables.forEach(r => {
                if (r instanceof PlantSubMenu && r.isHovered) {
                    console.log(`Submenu item clicked: ${r.action}`);
                    isSubMenuOpen = false; 
                    subMenuItemClicked = true;
                }
            });

            if (subMenuItemClicked) return;

            renderables.forEach(r => {
                if (r instanceof Node && r.isHovered) {
                    const modal = document.getElementById('serviceModal');
                    const modalContent = modal.querySelector('.modal-content');
                    const modalTitle = document.getElementById('modalTitle');
                    const modalDescription = document.getElementById('modalDescription');
                    
                    modalTitle.textContent = serviceData[r.serviceKey].title;
                    modalDescription.textContent = serviceData[r.serviceKey].full;

                    const gradient = `linear-gradient(45deg, ${r.colors[0]}, ${r.colors[1]})`;
                    modalContent.style.borderColor = r.colors[0];
                    modalContent.style.boxShadow = `0 0 40px ${r.colors[0]}, inset 0 0 15px ${r.colors[1]}a0`;

                    modalTitle.style.background = gradient;
                    modalTitle.style.webkitBackgroundClip = 'text';
                    modalTitle.style.webkitTextFillColor = 'transparent';
                    modalTitle.style.backgroundClip = 'text';
                    
                    modal.classList.add('active');
                }
            });
        });

        const modal = document.getElementById('serviceModal');
        const modalClose = document.getElementById('modalClose');
        modalClose.addEventListener('click', () => { modal.classList.remove('active'); });
        modal.addEventListener('click', (e) => {
            if (e.target === modal) { modal.classList.remove('active'); }
        });

    </script>
</body>
</html>